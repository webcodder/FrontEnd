<krpano>
<!--  全局调用属性  -->
<skin_settings webvr_gyro_keeplookingdirection="false" webvr_prev_next_hotspots="true" webvr_loadscene_flags="MERGE" webvr_loadscene_blend_prev="SLIDEBLEND(0.5, 180, 0.75, linear)" webvr_loadscene_blend_next="SLIDEBLEND(0.5, 0, 0.75, linear)"/>
<!--  引用 VR XML 插件   -->
<include url="%SWFPATH%/plugins/webvr.xml" devices="html5"/>
<!--  VR 核心 JS插件   -->
<plugin name="WebVR" keep="true" devices="html5" pluginurl="%SWFPATH%/plugins/webvr.js" url="" multireslock.desktop="true" multireslock.mobile.or.tablet="false" mobilevr_support="true" mobilevr_fake_support="true" onavailable="removelayer(webvr_enterbutton); skin_arrange_buttons(); webvr_onavailable();" onentervr="skin_showloading(false); webvr_onentervr(); webvr_setup(); skin_reloadscene_webvr();normalhs_enterVR();set(Inter,hide);Interface();" onexitvr="webvr_onexitvr(); webvr_setup(); skin_reloadscene_webvr();normalhs_exitVR();set(Inter,show);Interface();"/>
<action name="Interface" type="Javascript" devices="html5">
<![CDATA[
var hss1 = krpano.get("Inter");
 if(hss1 == "hide"){ 
 $(".top_bar,.zimu,#box").hide();
 }else{
 $(".top_bar,.zimu,#box").show();
 
 }
]]>
</action>
<!--  VR 控制面板样式   -->
<style name="webvr_button_style" border="false" roundedge="calc:1.0" backgroundcolor="0x2D3E50" backgroundalpha="0x2D3E50" shadow="0.01" shadowrange="10.0" shadowangle="90.0" shadowcolor="0x30261B" shadowalpha="0.50" css="color:#FFFFFF; font-family:微软雅黑;font-size:16px;"/>
<!--  手机端 横竖屏 VR模式下 提示  -->
<layer name="webvr_rotate_to_landscape_request" keep="true" vr="true" devices="mobile" url="%SWFPATH%/thumb/images/rotate_device.png" scale="0.5" align="top" edge="center" y="28%" autoalpha="true" alpha="0.0" enabled="false"/>
<events name="webvr_events" keep="true" devices="html5" onxmlcomplete="webvr_set_startup_view()" onresize.mobile="webvr_act_as_gyro_in_portrait_mode();" onloadcomplete="delayedcall(0.5, if(webvr.isenabled AND scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots, set(hotspot[webvr_prev_scene].visible,true); set(hotspot[webvr_next_scene].visible,true); set(hotspot[webvr_menu_bg].visible, true); set(hotspot[webvr_prev_home].visible, true);); );" onviewchange=""/>
<action name="webvr_set_startup_view">
if((webvr.isenabled OR plugin[skin_gyro].enabled) AND skin_settings.webvr_gyro_keeplookingdirection == false, skin_lookat( get(xml.view.hlookat) ); );
</action>
<action name="webvr_setup">
if(webvr.isenabled, copy(loadscene_flags_backup, skin_settings.webvr_loadscene_flags); set(skin_settings.webvr_loadscene_flags, MERGE|KEEPVIEW|KEEPMOVING|NOPREVIEW); webvr_act_as_gyro_in_portrait_mode(true); if(scene.count GT 1 AND skin_settings.webvr_prev_next_hotspots, set(hotspot[webvr_prev_scene].visible, true); set(hotspot[webvr_next_scene].visible, true); set(hotspot[webvr_menu_bg].visible, true); set(hotspot[webvr_prev_home].visible, true); set(events[webvr_events].onviewchange, webvr_menu_following()); ); , if(loadscene_flags_backup !== null, copy(skin_settings.webvr_loadscene_flags, loadscene_flags_backup)); tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0); set(hotspot[webvr_prev_scene].visible, false); set(hotspot[webvr_next_scene].visible, false); set(hotspot[webvr_menu_bg].visible, false); set(hotspot[webvr_prev_home].visible, false); set(events[webvr_events].onviewchange, null); );
</action>
<action name="webvr_act_as_gyro_in_portrait_mode">
if(device.mobile AND webvr.isenabled, div(aspect, stagewidth, stageheight); if(aspect != lastaspect OR '%1' == 'true', copy(lastaspect, aspect); if(stagewidth GT stageheight,
<!--
 landscape orientation - use stereo rendering and a direct/fast gyro sensor mode 
-->
set(display.stereo, true); set(webvr.mobilevr_sensor_mode, 3); webvr.update(); tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 0.0); ,
<!--
 portrait orientation - use normal rendering and a smoother/slower gyro sensor mode 
-->
set(display.stereo, false); set(webvr.mobilevr_sensor_mode, 1); webvr.update(); tween(layer[webvr_rotate_to_landscape_request].alpha, 1.0); delayedcall(3.0, tween(layer[webvr_rotate_to_landscape_request].alpha, 0.0, 1.0); ); ); ); , set(lastaspect, 0); );
</action>
<!--  VR 场景控制面板  上一个场景 与下一个场景 热点   -->
<style name="webvr_menu_style" depth="800" scale="0.5" distorted="true" ath="0" atv="45" alpha="1.0"/>
<style name="skin_basevr" url="%SWFPATH%/thumb/images/vr_left.png"/>
<style name="vr_menu_style" depth="800" scale="0.2" url="%SWFPATH%/thumb/images/black.png" distorted="true" ath="0" atv="45" alpha="0.35" visible="false"/>
<hotspot name="webvr_menu_bg" style="vr_menu_style" keep="true" zorder="5" width="850" height="160" handcursor="false" visible="false" devices="html5.and.webgl"/>
<hotspot name="webvr_prev_home" keep="true" zorder="6" style="skin_basevr|webvr_menu_style" crop="128|0|64|64" ox="0" onover="tween(scale,0.7);" onout="tween(scale,0.5);" vr_timeout="750" onclick="start_thumbs();" visible="false" devices="html5.and.webgl"/>
<hotspot name="webvr_prev_scene" keep="true" zorder="6" style="skin_basevr|webvr_menu_style" crop="0|0|64|64" ox="-64" onover="tween(scale,0.7);" onout="tween(scale,0.5);" vr_timeout="750" onclick="skin_nextscene_loop_webvr(-1);" visible="false" devices="html5.and.webgl"/>
<hotspot name="webvr_next_scene" keep="true" zorder="6" style="skin_basevr|webvr_menu_style" crop="64|0|64|64" ox="+64" onover="tween(scale,0.7);" onout="tween(scale,0.5);" vr_timeout="750" onclick="skin_nextscene_loop_webvr(+1);" visible="false" devices="html5.and.webgl"/>
<!--  JS 属性  -->
<action name="webvr_menu_following" type="Javascript" devices="html5">
<![CDATA[
var hs1 = krpano.get("hotspot[webvr_menu_bg]");
 var hs2 = krpano.get("hotspot[webvr_prev_home]");
 var hs3 = krpano.get("hotspot[webvr_prev_scene]");
 var hs4 = krpano.get("hotspot[webvr_next_scene]");
 if(!hs1.hovering && !hs2.hovering && !hs3.hovering && !hs4.hovering)
 {
 var f = 0.02;	
 // follow speed factor
 var h = krpano.view.hlookat;
 var v = krpano.view.vlookat;
 var hsh = hs1.ath;
 var hsv = hs1.atv;
 // map to -180 to +180
 h = (h -(h|0)) + (((h|0) +360180)%360) - 180.0;
 hsh = (hsh-(hsh|0)) + (((hsh|0)+360180)%360) - 180.0;
 // get the shortest horizontal distance
 dh = h - hsh;
 dh += (dh>180) ? -360 : (dh<-180) ? 360 : 0;
 // follow slowing horizontally
 hsh += dh*f;
 // fade out when farther away
 var a = Math.abs(v - hs1.atv) / 90.0;
 a = 0.5 * Math.max(1.0 - 2.0*Math.sqrt(a), 0);
 // move up the more looking down
 v = v + 55.0 - v*1.5;
 hsv = hsv*(1-f) + v*f;
 // set everything
 hs2.alpha = hs1.alpha = a;
 if(!hs3.hovering) hs3.alpha = a;
 if(!hs4.hovering) hs4.alpha = a;
 hs4.ath = hs3.ath = hs2.ath = hs1.ath = hsh;
 hs4.atv = hs3.atv = hs2.atv = hs1.atv = hsv;
 }
]]>
</action>
<!--  skin events  -->
<events name="skin_events_webvr" keep="true" onxmlcomplete="skin_startup_webvr();" onnewpano="if(webvr.isenabled,normalhs_enterVR(););"/>
<action name="normalhs_enterVR">
for(set(i,0), i LT hotspot.count, inc(i), if(hotspot[get(i)].normal == false , set(hotspot[get(i)].visible, false); ); );
</action>
<action name="normalhs_exitVR">
for(set(i,0), i LT hotspot.count, inc(i), if(hotspot[get(i)].normal == false , set(hotspot[get(i)].visible, true); ); );
</action>
<!--  skin actions  -->
<action name="skin_startup_webvr">
if(skin_settings.webvr AND device.html5 AND device.webgl, copy(plugin[WebVR].url, plugin[WebVR].pluginurl); );
</action>
<!--  VR点击事件  -->
<action name="skin_nextscene_loop_webvr">
add(newsceneindex, scene[get(xml.scene)].index, %1); sub(lastsceneindex, scene.count, 1); if(newsceneindex LT 0, copy(newsceneindex,lastsceneindex)); if(newsceneindex GT lastsceneindex, set(newsceneindex,0)); skin_loadscene_webvr(get(newsceneindex), calc(%1 LT 0 ? skin_settings.webvr_loadscene_blend_prev : skin_settings.webvr_loadscene_blend_next));
</action>
<action name="skin_loadscene_webvr">
if(webvr.isenabled AND scene.count GT 1, set(hotspot[webvr_prev_scene].visible, false); set(hotspot[webvr_next_scene].visible, false); ); txtadd(layer[skin_thumbborder].parent, 'skin_thumb_', get(scene[%1].index)); layer[skin_thumbs].scrolltocenter(get(scene[%1].thumbx), get(scene[%1].thumby)); loadscene(get(scene[%1].name), null, get(skin_settings.webvr_loadscene_flags), %2);
</action>
<!--  VR点击事件  -->
<!--
 reload the scene when there is a special image for VR 
-->
<action name="skin_reloadscene_webvr">
delayedcall(0.1, if(scene[get(xml.scene)].havevrimage, copy(keeplookingdirection_backup, skin_settings.webvr_gyro_keeplookingdirection); set(skin_settings.webvr_gyro_keeplookingdirection, true); loadscene(get(xml.scene), null, MERGE|KEEPVIEW|KEEPMOVING|KEEPHOTSPOTS|NOPREVIEW, BLEND(0.5)); copy(skin_settings.webvr_gyro_keeplookingdirection, keeplookingdirection_backup); delete(keeplookingdirection_backup); ); );
</action>
<style name="panel" distorted="true" enabled="false" zorder="1" url="%SWFPATH%/thumb/images/black.png" width="100" height="70" alpha="0" depth="700" ty="10000" keep="true"/>
<style name="thumb" distorted="true" enabled="false" zorder="3" capture="false" alpha="0" depth="700" ty="10000" width="90" height="60" onover="tween(depth,500);" onout="tween(depth,700);" keep="true"/>
<action name="webvr_enterVR">
delayedcall(2.0,add_vr_thumbs();); WebVR_onremovepano();
</action>
<action name="add_vr_thumbs">
set(vr_hot_ath,0); set(vr_hot_atv,0); set(vr_ts,true); for(set(i,0), i LT scene.count, inc(i), set(vr_thumbs,get(scene[get(i)].name)); if(vr_ts, set(vr_thumbs_bg,vr_tishi_bg); set(vr_thumbs,vr_tishi); set(vr_hot_url,'%SWFPATH%/thumb/images/texts.png'); set(vr_ts,false); sub(i,1); , txtadd(vr_thumbs_bg,get(vr_thumbs),'bg'); set(vr_hot_url,get(scene[get(vr_thumbs)].thumburl)); ); if((vr_hot_ath == 360) OR (vr_hot_ath == 720) OR (vr_hot_ath == 1080), add(vr_hot_atv,15); ); addhotspot(get(vr_thumbs_bg)); hotspot[get(vr_thumbs_bg)].loadstyle(panel); set(hotspot[get(vr_thumbs_bg)].ath,get(vr_hot_ath)); set(hotspot[get(vr_thumbs_bg)].atv,get(vr_hot_atv)); addhotspot(get(vr_thumbs)); set(hotspot[get(vr_thumbs)].ath,get(vr_hot_ath)); set(hotspot[get(vr_thumbs)].atv,get(vr_hot_atv)); set(hotspot[get(vr_thumbs)].url,get(vr_hot_url)); if((vr_hot_ath == vr_ts) AND (vr_hot_atv == 0), set(hotspot[vr_tishi].crop,287|0|252|176); , txtadd(hotspot[get(vr_thumbs)].onclick,"start_thumbs(exit);loadscene(",get(vr_thumbs),", null, NOPREVIEW|MERGE|KEEPMOVING, BLEND(1));" ); ); hotspot[get(vr_thumbs)].loadstyle(thumb); add(vr_hot_ath,20); );
</action>
<action name="start_thumbs">
set(start_ty, 10000); add(vr_juli,get(view.hlookat),20); if(%1 == "exit", callwith(hotspot[vr_tishi_bg],tween(alpha|ty, 0|10000,2.5, easeInQuint|easeInQuint);); callwith(hotspot[vr_tishi], tween(alpha|ty, 0|10000,2.5, easeInQuint|easeInQuint, set(enabled,false));); , set(hotspot[vr_tishi_bg].ath,get(view.hlookat)); set(hotspot[vr_tishi].ath,get(view.hlookat)); callwith(hotspot[vr_tishi_bg], copy(ty,start_ty);tween(alpha|ty, 0.5|0 , 3, easeOutQuad|easeOutQuint);); callwith(hotspot[vr_tishi], copy(ty,start_ty);tween(alpha|ty, 1.0|0 , 3, easeOutQuad|easeOutQuint, set(enabled,true));); vr_yc_thumbs_time(0); ); for(set(i,0), i LT scene.count, inc(i), set(vr_thumbs,get(scene[get(i)].name)); txtadd(vr_thumbs_bg,get(vr_thumbs),'bg'); if(%1 == "exit", callwith(hotspot[get(vr_thumbs_bg)], tween(alpha|ty, 0|10000,2.5, easeInQuint|easeInQuint);); callwith(hotspot[get(vr_thumbs)], tween(alpha|ty, 0|10000,2.5, easeInQuint|easeInQuint, set(enabled,false));); , set(hotspot[get(vr_thumbs_bg)].ath,get(vr_juli)); set(hotspot[get(vr_thumbs)].ath,get(vr_juli)); callwith(hotspot[get(vr_thumbs_bg)], copy(ty,start_ty);tween(alpha|ty, 0.5|0 , 3,easeOutQuad|easeOutQuint);); callwith(hotspot[get(vr_thumbs)], copy(ty,start_ty);tween(alpha|ty, 1.0|0 , 3,easeOutQuad|easeOutQuint, set(enabled,true));); add(vr_juli,20); ); );
</action>
<action protect="true" name="vr_yc_thumbs_time">
set(vr_time,%1); add(vr_time,1); set(time_kz,true); if(vr_time == 15, delete(time_kz,vr_time);start_thumbs(exit);); if(time_kz, delayedcall(1,vr_yc_thumbs_time(get(vr_time))););
</action>
<!--  webvr 按钮属性  -->
<action name="skin_btn_vr_onloaded">
calc(show_vrbutton,webvr.isavailable == true); if(show_dirbuttons,	copy(layer[skin_btn_vr].visible, show_vrbutton);	,	copy(layer[skin_btn_vr].visible, show_vrbutton);	);
</action>
</krpano>